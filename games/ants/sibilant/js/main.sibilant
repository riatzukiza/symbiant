(include "./deps")
(import-namespace defs)
(import-namespace js)
(macro every (amount time ...body) `(when (= (mod  @time @amount) 0) ...@body))
;; Libs
(import (euclidian-distance) "./math")
(import ( create extend mixin) "./util")
(const $ (require "jquery/dist/jquery.min.js"))
(const fs (require "browserify-fs"))
;; Types
(import (Matrix) "./matrix" )
(import (State-space) "./state-space")
(import (Simulation) "./simulation")

;;(import (Entity) "./ecs/entity")

(import (Display) "./display" )
(import (Layer) "./layer" )
(import (interface) "./interface")
(import (Pheremones) "./pheremons")
(import (complement) "./color")
(import (weighted-random-element) "./random")
(let george { x 20 y 20 })
;; Declare variables
(let socket (io "/ants"))
(Simulation let sim (120 120 5))
(let white (color 255 255 255))
(let green (color 0 255 0))
(let black (color 0 0 0))

(macro area-has (diameter spot center area cond)
       `(scoped (let true? false)
           (area  @area @spot @center @diameter
                  (when @cond (assign true? true)))
                true?))
(macro gene (ent value)
       `(get @ent (quote genetics) (quote @value)))
(macro mutate (ent values)
       (map (content-of values) (value)
            `(assign (get @ent (quote genetics) (quote @value))
                  (+ (get @ent (quote genetics) (quote @value))
                     (random-signed (get @ent (quote genetics) (quote mutation-factor)))))))
(generic moore-neighborhood (def) (w h (weight 1) (c 0))
         (let m (allns w h weight))
         (set m.array (matrix-center w h) c) m)
(def matrix-center (width height )
  (Math.round (/ (- (* width height) 1) 2)))
(let empty { id 0 })
(let choice {x 60 y 60})
(macro collide (ent ...body) `(if (or (not @ent) (= @ent empty) (= @ent 0))
                                  (do ...@body)))
(macro area (space el-name center size ...body)
       `(each-in-area @space @center
                     (=> (@el-name i j x y)
                         ...@body) @size ))
(macro adjacent (matrix value-name center ...body)
       `(area @matrix @value-name @center 3 ...@body))
(macro if-valid-move (ent ...body )
       `(when (or (not @ent) (= @ent empty) (= @ent 0)) ...@body))
(macro each-valid-move (ent space ...rest)
       `(adjacent @space w @ent
                  (let ent (.get collision x y))
                  (if-valid-move ent ...@rest)))
(generic each-in-area (fn) (matrix pos f (size 3) (rad (Math.floor (/ size 2))))
         "apply a function to every element in a kernel of the weight matrix.
Values are not changed unless done so explicitly by the function as a side effect."
         (.each-in-sub matrix
                       (- pos.x rad)
                       (- pos.y rad)
                       size size (=> (v i j x y ) (f v i j (+ x i) (+ y j)))))
(macro genetics (assigner ...props)
       `(@assigner genetics (p-map ...@(map props (p)

                                   (if (literal? p) `( @p (random-float 0 0.5))
                                       `( @(first (content-of p))
                                           @(second (content-of p))))))))



(macro member (name value)
       `(set this (quote @name) @value))
(type Collision
      (property coord sim.coord)
      (init ((entities (new Map) ) coord))
      (generic serialize (mth) (entities)
               (map (.to-array entities) (ent) (.serialize ent)))
      (generic move (mth) (ent pos entities)
               (.delete entities ent.pos)
               (.set entities pos ent))
      (generic check (mth) (x y coord )
               (this.has (.get coord x y)))
      (generic set (mth) (pos ent entities)
               (.set entities pos ent))
      (generic get (mth) (x y entities coord)
               (.get entities (.get coord x y)))
      (generic delete (mth) (key )
               (.delete this.entities key))
      (generic has (mth) (pos entities)
               (.has entities pos)))
(type Movement (init ()))
(type Rendering
      (property entities (.get sim.layers))
      (property weights []))
(type World
      (property collision ((create Collision)))
      (property coord sim.coord)
      (property rendering Rendering)
      (property entities (new Set))
      (init (collision  coord gl-layer))
      (gmth add (ent rendering collision coord entities)
            (.add rendering.entities ent)
            (.add entities ent)
            (.set collision ent.pos ent))
      (gmth delete (ent rendering collision coord entities)
            (.delete rendering.entities ent)
            (.delete entities ent)
            (.delete collision ent.pos ))
      (gmth update (entities)
            (each entities (ent) (.update ent))))
(macro gett (name ...body)
       ["get " `(mth @name () ...@body)])

(macro sett (name val ...body)
       ["set " `(mth @name (@val) ...@body)])
(type Entity
      (property world World)
      (property collision World.collision)
      (init (pos world color collision ))

      (gett r  this.color.red)
      (gett g  this.color.green)
      (gett b  this.color.blue)
      (gett a  255)
      (gett x  this.pos.x)
      (gett y  this.pos.y)
      (sett x num (.move this num this.y))
      (sett y num (.move this this.x num))

      (gmth spawn (x y color world collision)
            (let pos (.get world.coord x y))
            (unless (collision.has pos )
              (let ent ((create this) pos world color))
              (world.add ent) ent))
      (gmth move (x y world collision)
            (let pos (.get world.coord x y))
            (unless (collision.has pos )
              (.move collision this pos)
              (assign this.pos pos)))
      (gmth delete (world)
            (.delete world this))
      (generic random (mth) ( world )
               (.spawn this
                       (random-int 0 world.coord.width)
                       (random-int 0 world.coord.width))))
(assign Entity.empty empty)
(specify Entity-group (extend Entity)
         (property groups (new Set))
         (init (entity-type (entities (new Set)) groups)
               (.add groups this))
         (generic serialize (mth) (entities)
                  (map (.to-array entities) (ent)
                       (.serialize ent)))
         (generic add (mth) (ent entities)
                  (assign ent.group this)
                  (.add entities ent))
         (generic has (mth) (ent entities)
                  (.has entities ent))
         (generic delete (mth) (ent entities)
                  (.delete entities ent)
                  (.delete ent)
                  )
         (generic remove (mth) (ent entities)
                  (assign ent.group null)
                  (.delete entities ent))
         (generic each (mth) (f entities)
                  (.each entities f) this)
         (generic spawn (fluent mth) (x y color entity-type)
                  (let ent (.spawn entity-type  x y color ))
                  (when ent
                      (assign ent.group this)
                      (this.add ent) ent))
         (generic update (mth) (entities)
                  (each entities (ent) (.update ent))))
;; FIRST PERSON TO GIVE ME A COLOR, I WILL USE IT FOR THIS TEST ANT!
(specify Straight-liner (extend Entity)
         (property color (color 0 151 116))
         (gmth update ()
               (++ this.x)
               (++ this.y)))
(specify Ant (extend Entity)
         (property life 1000)
         (init ( pos world color life (ant this) )
               (genetics  member (deviance (random-signed 0.1)) rate mutation-factor
                          (find-rate (random-signed 1))
                          (return-rate (random-signed 1))
                          (kernel (.dmap (moore-neighborhood 3 3) (-> (random-signed 1))))))
         (generic *has-discovered-food (mth) ( group collision ant)
                  (let true? false)
                  (area  World.coord spot ant 5
                         (assign spot (.get World.collision.entities spot))
                         (when (and  (not true?) (.has group.goals spot) )
                           (assign this._food spot)
                           (assign true? true))) true?)

         (generic *eat (mth) ( group ant)
                  (.delete group.goals ant._food)
                  (assign ant.life (+ ant.life ant._food.life))
                  (let emission (* (gene ant rate) (gene ant find-rate) 10))
                  (.emit Pheremones ant.pos group.weights  emission 120))
         (generic *reproduce (mth) (nest ant group )
                  (assign ant.life (/ ant.life 2))
                  (.mutate ant )
                  (.spawn group )
                  (.spawn group )
                  (.emit Pheremones ant.pos group.weights (* 100  (gene ant rate) (/ ant.life Ant.life)) 20))
         (generic *die (mth) (  ant group collision)
                  (.delete group ant)
                  (.emit Pheremones ant.pos group.weights (* -10 (gene ant rate)  (/ ant.life Ant.life)) 20)
                  )
         (generic mutate (mth) (ant group nest)
                  ;; me think mutations aughta be put into some fancy ass abstraction some where.
                  (.emit Pheremones ant.pos group.weights (- (gene ant rate)))
                  (.dmap (gene ant kernel) (=> (x) (* x (random-signed 0.2))))
                  (mutate ant (return-rate find-rate deviance rate) )
                  (assign ant.life Ant.life ))
         (generic *sated (mth) (nest ant collision)
                  (> ant.life Ant.life) )
         (generic *near-nest (mth) (nest ant )
                  (area-has 10 spot ant World.coord (and (= nest.x x) (= nest.y y))))
         ;; This is the function we should be calling in most instances to create an ant.
         ;; Ants should belong to a colony.
         ;; So there should be a method associated with the colony for creating ants via this method.
         (generic choose (mth) (group collision  (ant this) )
                  ;; A choice is a weighted random selection from a collection area.
                  (let count 0)
                  (let sum 0)
                  (let done false)
                  (let choice {
                    x ant.x
                    y ant.y
                    })
                  ;; I think this ends up being needed in multiple places.
                  ;; but in what way?
                  ;; I think some other function will decide what *weight* is, and call this function accordingly.
                  (when (not (gene ant kernel))
                    (assign (gene ant kernel) (moore-neighborhood 3 3 (gene ant deviance))))
                  (let sated? 1)
                  (each-valid-move  ant group.weights.state
                                    (comment (let calc-devi (/ (* Ant.life ant.life)
                                                       (gene ant deviance))))
                                    ;;(print "calculated deviance" calc-devi)
                                    (incr-by count (* w  sated?
                                                      (/ ant.life Ant.life)
                                                      (.get (gene ant kernel) i j)
                                                      (gene ant deviance))))
                  (let rand (* count (Math.random)))
                  (each-valid-move ant group.weights.state
                                   (incr-by sum (* w   sated?
                                                   (/ ant.life Ant.life)
                                                   (.get (gene ant kernel) i j)
                                                   (gene ant deviance)))
                                   (when (and (< rand sum) (not done))
                                     (assign choice.x x choice.y y done true))) choice)
         (generic update (mth) (  group nest  life  (ant this))
                  ;; Ants are more likely to choose pheremones over none.
                  ;; but the chance must still exist for the ant to take non marked paths for this to work
                  (let x 0)
                  (let y 0)
                  (-- ant.life)
                  (let random (random-int 0 (/ Ant.life 2)))
                  ;; Randomly kill off ants who's lives are
                  ;; below a random threshold between some value and 0
                  (let sated? (.*sated ant ))

                  (if (> (* 0.1 ant.life ) (* 100 (+ 10 random)))
                      (do (print "Fuck you guys, I'll make my own colony, with black jack and hookers." ant.life (* 100 random))
                          (let new-colony ((create Colony) this.pos (random-color)
                                           (weighted-random-element
                                            Entity-group.groups
                                            (=> (group)
                                                (let total-life 0)
                                                (each group.entities (ent)
                                                      (incr-by total-life ent.life)) total-life)) ))
                        (.remove this.group this)
                        (.add new-colony this)
                        (assign this.color new-colony.color))

                   (> (* 2 ant.life) random)
                      (do (let choice (.choose ant ))
                          (.move this choice.x choice.y  )
                        (if (.*has-discovered-food  ant ) (.*eat ant )
                            sated? (if (.*near-nest  ant) (.*reproduce ant))))
                      (.*die ant))
                  (.emit Pheremones ant.pos group.weights (* (gene ant rate) (* 0.1 (/ ant.life Ant.life))) 7)))
(specify Colony (extend Entity-group)
         (property colonies (new Set) )
         (property entity-type Ant)
         (init (nest color goals (decay 0.1) colonies (weights ((create State-space) sim.width sim.width)))
               (Entity-group.init.call this)
               (assign weights.layer (.get sim.layers))
               (each weights (w x y)
                     (.add weights.layer
                           (literal
                            x y
                            (gett weight (.get weights x y))
                            (gett color (if (>= this.weight 0 )
                                            color
                                            (complement color)))
                            (gett r this.color.red )
                            (gett g this.color.green)
                            (gett b this.color.blue)

                            (gett a (Math.abs (* 160 this.weight)) ))))
               (.move-up weights.layer)

               (.add colonies this))
         (generic spawn (fluent mth) (color entity-type)
                  (let rx (ternary (= (random-bit) 1) 1 -1))
                  (let ry (ternary (= (random-bit) 1) 1 -1))
                  (let ent (.spawn entity-type
                                   (+ this.nest.x (random-int 0 30) rx)
                                   (+ this.nest.y (random-int 0 30) rx) color))
                  (when ent
                    (assign ent.group this)
                    (this.add ent)
                    (assign ent.nest this.nest)
                    ent))
         (generic serialize (mth) (ants)
                  (map (.to-array ants) (ant) (.serialize ant)))
         (generic update (mth) (entities weights decay)
                  "Process the movement of ever ant in a set of ants, updating weights along the way."
                  (.each this (=> (ant) (.update ant )))
                  (.update Pheremones this.weights 0.1 )))

(specify Plant (extend Entity)
         (property color green)
         (property life 200)
         (gmth update (pos system)
               (when (= (random-bit) 1)

                   (var rx (ternary (= (random-bit) 1) 1 -1) )
                   (var ry (ternary (= (random-bit) 1) 1 -1) )
                   (request-animation-frame
                    (-> (.spawn this.group
                                (+ pos.x (random-int 0 2) rx)
                                (+ pos.y (random-int 0 2) ry) this.color))))))

(specify Plant-group (extend Entity-group)
         (property entity-type Plant)
         )
(def Map.prototype.each (f)
  (.for-each this f) this)
(def start (sim)
  (let plants ((create Plant-group) ))
  (let reds ((create Colony) { x 30 y 60} (color 255 0 0) plants ))
  (let georges ((create Colony) { x 90 y 90} yellow reds ))
  (assign global.sim sim)
  ;;(let line-walker (.spawn Straight-liner 60 60))
  (do-times 1000 (.spawn reds))
  (do-times 100 (.spawn georges))
  (do-times 1000 (.random plants  ))
  ;;(interface sim)
  (on (sim.start)"tick" (now ticks)

      (every 60 ticks
             (.update plants))
      (do-times 2
        (each Colony.colonies (col)
              (.update col)))
      (pipe sim.layers
            (.update )
            (.render))))
(let yellow { red 255 green 255 blue 0 })
(.load sim  start)
(on socket "change" () (print "change ") (.reload location))


(import ( create extend mixin) "../util")
(import (Entity) "../ecs/entity")
(import (Entity-group) "../ecs/group")
(import (Matrix) "../matrix" )
(import (Pheremones) "../pheremons")
(import (weighted-random-element) "../random")
(import (State-space) "../state-space")

(import (complement) "../color")


(generic moore-neighborhood (def) (w h (weight 1) (c 0))

         (let m (allns w h weight))
         (set m.array (matrix-center w h) c) m)

(def matrix-center (width height )
  (Math.round (/ (- (* width height) 1) 2)))


(macro if-valid-move (ent ...body )
       `(when (or (not @ent) (= @ent 0)) ...@body))

(import (each-in-area) "../area")

(specify Ant (extend Entity)
         (property life 1000)
         (property collision world.collision)
         (init ( pos color life (ant this) )
               (genetics  member (deviance (random-signed 0.1)) rate mutation-factor
                          (find-rate (random-signed 1))
                          (return-rate (random-signed 1))
                          (kernel (.dmap (moore-neighborhood 3 3) (-> (random-signed 1))))))
         (generic *has-discovered-food (mth) ( group  ant)
                  (let true? false)
                  (area  world.coord spot ant 5
                         (assign spot (.get world.collision.entities spot))
                         (when (and  (not true?) (.has group.goals spot) )
                           (assign this._food spot)
                           (assign true? true))) true?)

         (generic *eat (mth) ( group ant)
                  (.delete group.goals ant._food)
                  (assign ant.life (+ ant.life ant._food.life))
                  (let emission (* (gene ant rate) (gene ant find-rate) 10))
                  (.emit this.group.food-weights ant.pos group.weights  emission 20))
         (generic *reproduce (mth) (nest ant group )
                  (assign ant.life (/ ant.life 2))
                  (.mutate ant )
                  (.spawn group )
                  (.spawn group )
                  (.emit this.group.mating-weights ant.pos group.mating-weights.weights
                         (* 100  (gene ant rate) (/ ant.life Ant.life)) 20))
         (generic *die (mth) (  ant group )
                  (.delete group ant)
                  (.emit this.seeking ant.pos this.seeking.weights (* -10 (gene ant rate)  (/ ant.life Ant.life)) 20)
                  )
         (generic mutate (mth) (ant group nest)
                  ;; me think mutations aughta be put into some fancy ass abstraction some where.
                  (.emit this.group.food-weights ant.pos group.weights (- (gene ant rate)))
                  (.dmap (gene ant kernel) (=> (x) (* x (random-signed 0.2))))
                  (mutate ant (return-rate find-rate deviance rate) )
                  (assign ant.life Ant.life ))
         (generic *sated (mth) (nest ant )
                  (let sated? (> ant.life Ant.life))
                  (if sated? (assign this.seeking this.group.mating-weights)
                      (assign this.seeking this.group.food-weights))
                  sated?)

         (generic *near-nest (mth) (nest ant )
                  (area-has 10 spot ant world.coord (and (= nest.x x) (= nest.y y))))
         ;; This is the function we should be calling in most instances to create an ant.
         ;; Ants should belong to a colony.
         ;; So there should be a method associated with the colony for creating ants via this method.
         (generic choose (mth) (group collision  (ant this) )
                  ;; A choice is a weighted random selection from a collection area.
                  (let count 0)
                  (let sum 0)
                  (let done false)
                  (let choice {
                    x ant.x
                    y ant.y
                    })
                  ;; I think this ends up being needed in multiple places.
                  ;; but in what way?
                  ;; I think some other function will decide what *weight* is, and call this function accordingly.
                  (when (not (gene ant kernel))
                    (assign (gene ant kernel) (moore-neighborhood 3 3 (gene ant deviance))))
                  (let weights null)
                  (each-valid-move  ant this.seeking.weights.state
                                    (incr-by count (+ 1 (* w
                                                       (/ ant.life Ant.life)
                                                       (.get (gene ant kernel) i j)
                                                       (gene ant deviance)))))
                  (let rand (* count (Math.random)))
                  (each-valid-move ant this.seeking.weights.state
                                   (incr-by sum (+ 1(* w
                                                    (/ ant.life Ant.life)
                                                    (.get (gene ant kernel) i j)
                                                    (gene ant deviance))))
                                   (when (and (< rand sum) (not done))
                                     (assign choice.x x choice.y y done true)))

                  (print "choice" choice rand count sum)
                  choice)
         (generic *form-new-colony (mth) ()
                  (let sum-groups-life (=> (group)
                                           (let total-life 0)
                                           (each group.entities (ent)
                                                 (incr-by total-life ent.life)) total-life))
                  (let new-colony ((create Colony) this.pos (random-color)
                                      (weighted-random-element Entity-group.groups sum-groups-life) ))
                  (print "creating new colony" new-colony)
                  (.remove this.group this)
                  (.add new-colony this)
                  (do-times 10 (.*reproduce this))
                  (assign this.color new-colony.color))
         (generic update (mth) (  group nest  life  (ant this))
                  ;; Ants are more likely to choose food-weights over none.
                  ;; but the chance must still exist for the ant to take non marked paths for this to work
                  (let x 0)
                  (let y 0)
                  (-- ant.life)
                  (let random (random-int 0 (/ Ant.life 2)))
                  ;; Randomly kill off ants who's lives are
                  ;; below a random threshold between some value and 0
                  (let sated? (.*sated ant ))
                  (if (> (* 2 ant.life) random)
                      (do (let choice (.choose ant ))
                          (.move this choice.x choice.y  )
                        (if sated? (if (.*near-nest  ant)
                                       (.*reproduce ant)
                                       (and (< group.colonies 30)(> (Math.random) 0.9999))
                                       (.*form-new-colony ant))
                            (.*has-discovered-food  ant )
                            (.*eat ant )))
                      (.*die ant))
                  (.emit this.seeking ant.pos this.seeking.weights (* (gene ant rate) (* 0.1 (/ ant.life Ant.life))) 20)))


(export Ant)

(import (Event-emitter) "events")
(specify Colony (extend Entity-group)
         (property colonies (new Set) )
         (property entity-type Ant)

         (init (nest color goals (decay 0.1) colonies

                     (food-weights ((create Pheremones) color decay (.get sim.layers)))

                     (mating-weights ((create Pheremones)
                                      (color color.red color.green 255)
                                      decay (.get sim.layers)))
                     (event (new Event-emitter)))
               (Entity-group.init.call this)

               (.add colonies this))
         (generic spawn (fluent mth) (color entity-type)
                  (let rx (ternary (= (random-bit) 1) 1 -1))
                  (let ry (ternary (= (random-bit) 1) 1 -1))
                  (let ent (.spawn entity-type
                                   (+ this.nest.x (random-int 0 30) rx)
                                   (+ this.nest.y (random-int 0 30) rx) color))
                  (when ent
                    (assign ent.group this)
                    (assign ent.seeking this.food-weights)
                    (this.add ent)
                    (assign ent.nest this.nest)
                    (.emit this.event "spawn" ent)
                    ent
                    ))

         (generic serialize (mth) (ants)
                  (map (.to-array ants) (ant) (.serialize ant)))

         (generic update (mth) (entities weights decay mating-weights food-weights)
                  "Process the movement of ever ant in a set of ants, updating weights along the way."
                  (.each this (=> (ant) (.update ant )))
                  (.update mating-weights)
                  (.update food-weights)
                  (when (= this.entities.size 0)
                    (print "colonly has died")
                    (.emit this.event "extinct" this)
                    (.remove sim.layers this.layer)
                    (.delete this.colonies this))))
(export Colony)


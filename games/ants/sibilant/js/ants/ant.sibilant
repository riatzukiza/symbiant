(macro genetics (assigner ...props)
       `(@assigner genetics
                   (p-map ...@(map props (p)
                                   (if (literal? p) `( @p (random-float 0 0.5))
                                       `( @(first (content-of p))
                                           @(second (content-of p))))))))
(macro area-has (diameter spot center area cond)
       `(scoped (let true? false)
           (area  @area @spot @center @diameter
                  (when @cond (assign true? true)))
                true?))
(macro gene (ent value)
       `(get @ent (quote genetics) (quote @value)))
(macro mutate (ent values)
       (map (content-of values) (value)
            `(assign (get @ent (quote genetics) (quote @value))
                  (+ (get @ent (quote genetics) (quote @value))
                     (random-signed (get @ent (quote genetics) (quote mutation-factor)))))))
(macro collide (ent ...body) `(if (or (not @ent) (= @ent empty) (= @ent 0))
                                  (do ...@body)))
(macro area (space el-name center size ...body)
       `(each-weight @space @center
                     (=> (@el-name i j x y)
                         ...@body) @size ))
(macro adjacent (matrix value-name center ...body)
       `(area @matrix @value-name @center 3 ...@body))
(macro if-valid-move (ent ...body )
       `(when (or (not @ent) (= @ent empty) (= @ent 0)) ...@body))
(macro each-valid-move (ent space ...rest)
       `(adjacent @space w @ent
                  (let ent (.get collision x y))
                  (if-valid-move ent ...@rest)))
(macro member (name value)
       `(set this (quote @name) @value))
(import (Entity) "../ecs/entity")
(import (Weight-field) "./weights")
(import ( create extend mixin) "../util")
(import (Matrix) "../matrix")
(let yellow { red 255 green 255 blue 0 })
(let empty { id 0 })
(assign Entity.empty empty)
(let choice {x 60 y 60})

(generic moore-neighborhood (def) (w h (weight 1) (c 0))
         (let m (allns w h weight))
         (set m.array (matrix-center w h) c) m)
(def matrix-center (width height )
  (Math.round (/ (- (* width height) 1) 2)))
(generic each-weight (fn) (weights pos f (size 3) (rad (Math.floor (/ size 2))))
         "apply a function to every element in a kernel of the weight matrix.
Values are not changed unless done so explicitly by the function as a side effect."
         (.each-in-sub weights.state
                       (- pos.x rad)
                       (- pos.y rad)
                       size size (=> (v i j x y ) (f v i j (+ x i) (+ y j)))))

(generic map-weights (fn) (weights pos f (size 3) (rad (Math.floor (/ size 2))))
         "apply a function to every element in a kernel of the weight matrix,
assigning the weight value to the value returned"
         (each-weight weights pos
                      (=> (w i j x y) (.set weights (+ x i) (+ y j) (f w i j x y))) size rad))

(specify Ant (extend Entity)
         (property life 1000)
         (init ( pos  system   life )
               (print "system" system)
               (.call Entity.init  this pos system)
               (genetics  member (deviance (random-signed 0.1)) rate mutation-factor
                          (find-rate (random-signed 1))
                          (return-rate (random-signed 1))
                          (kernel (.dmap (moore-neighborhood 3 3) (-> (random-signed 1))))))
         (generic serialize (mth) (genetics life) (literal genetics life x y))
         (generic save (mth) (path genetics life)
                  (fs.write-file "./sim.json"
                                 (JSON.stringify (.serialize this))
                                 (=> (err)
                                     (if err (.emit this "error" err))
                                     (.emit this "save" ))))
         (generic load (mth) ())
         ;; This is the function we should be calling in most instances to create an ant.
         ;; Ants should belong to a colony.
         ;; So there should be a method associated with the colony for creating ants via this method.
         (generic update (mth) (  ants nest  life  (ant this))
                  ;; Ants are more likely to choose pheremones over none.
                  ;; but the chance must still exist for the ant to take non marked paths for this to work
                  (let x 0)
                  (let y 0)
                  (-- ant.life)
                  (let random (random-int 0 (/ Ant.life 2)))
                  ;; Randomly kill off ants who's lives are
                  ;; below a random threshold between some value and 0
                  (let sated? (.*sated ant ))
                  (if (> (* 2 ant.life) random)
                      (do (let choice (.choose ant ))
                          (.move.call Entity ant choice.x choice.y  )
                        (if (.*has-discovered-food  ant ) (.*eat ant )
                            sated? (if (.*near-nest  ant) (.*reproduce ant))))
                      (.*die ant))
                  (.emit Weight-field ant weights (* (gene ant rate) (* 0.1 (/ ant.life Ant.life))) 7)))
(export Ant)

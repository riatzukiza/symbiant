(import ( create extend mixin) "../util")
(import (State-space) "../state-space")
(import (euclidian-distance) "../math")
(fn decay-positive (x y v decay color)
    "brings a positive weight closer to zero, "
    (- v  decay ))
(def combine (old addi ) (Math.round (+ old addi)))
(fn decay-negative (x y v decay color)
    "brings a positive weight closer to zero, "
    (+ v  decay ))
(generic each-weight (fn) (weights pos f (size 3) (rad (Math.floor (/ size 2))))
         "apply a function to every element in a kernel of the weight matrix.
Values are not changed unless done so explicitly by the function as a side effect."
         (.each-in-sub weights.state
                       (- pos.x rad)
                       (- pos.y rad)
                       size size (=> (v i j x y ) (f v i j (+ x i) (+ y j)))))
(def fall-off (w rate x y pos)
  (+ w (/ rate (+ 1 (Math.pow (euclidian-distance x y pos.x pos.y) 2)))))
(type Weight-field
      (init (sim decay (weights ((create State-space) sim.width sim.width))))
      (gmth emit  (pos weights rate (r 5 ))
            (area weights w pos r
                      (when (< w 1)
                        (let new-weight (fall-off w rate x y pos))
                        (weights.set x y new-weight))))
      (gmth count (ant weights)
            (let count 0)
            (each-valid-move  ant weights
                              (incr-by count (* w  sated?
                                                (.get-cell (gene ant kernel) i j)
                                                (/ (* Ant.life ant.life)
                                                   (gene ant deviance)))))
            count)
      (gmth update (weights decay )
            (weights.transit
             (=> (v x y)
                 (if (> v 0) (decay-positive x y v decay )
                     (< v 0) (decay-negative x y v decay ))))
            (.update weights)))
(export Weight-field)

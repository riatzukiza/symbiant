;; Pheremons is a weight matrix.
;; Every value in it is a floating point number from 0 to 1.
;; The values of this matrix influence the decisions of the ants.
;; Pheremons decay by a fixed amount every tick of the simulation unless
;; an ant has recently traversed that location.
;; The result of this is that long paths do not live as long,
;; so the ants will tend towards the shortest path.



(import ( create extend mixin) "./util")
(import (State-space) "./state-space")
(import (euclidian-distance) "./math")
(import (Layer) "./layer")
(import (hexToComplimentary) "./complimentry")

;;(import (each-weight) "./ant")

(let colors [])

(fn decay-positive (x y v display decay color)

    "brings a positive weight closer to zero, "

    (comment (let pixel (.get display x y))


             (blend pixel color v)


             (display.set x y pixel))

    (- v  decay ))

(def combine (old addi ) (Math.round (+ old addi)))

(def blend (color pixel v)

  (let b (combine pixel.red color.red))
  (let r (combine pixel.blue color.blue))
  (let g (combine pixel.green color.green))

  (let a (combine pixel.alpha v))

  (assign pixel.red r
          pixel.blue b
          pixel.green g
          pixel.alpha a
          ))

(fn decay-negative (x y v display decay color)

    "brings a positive weight closer to zero, "


    (comment (let pixel  (.get display x y))
             (let alpha pixel.alpha)

             (assign pixel (hexToComplimentary pixel))
             (assign pixel.alpha alpha)

             (blend  pixel color v)

             (display.set x y pixel))

    (+ v  decay ))

(generic each-weight (fn) (weights pos f (size 3) (rad (Math.floor (/ size 2))))

         "apply a function to every element in a kernel of the weight matrix.
Values are not changed unless done so explicitly by the function as a side effect."

         (.each-in-sub weights.state

                       (- pos.x rad)
                       (- pos.y rad)

                       size size (=> (v i j x y ) (f v i j (+ x i) (+ y j)))))

(type Pheremones

      (init ( rate decay color display weights))
      (gmth emit  (pos weights rate (r 5 ))

            (area weights w pos r

                      (when (< w 1)

                        (let new-weight (+ w (/ rate (+ 1 (Math.pow (euclidian-distance x y pos.x pos.y) 2)))))

                        (weights.set x y new-weight))))

      (gmth update (weights display decay color)

            (weights.transit

             (=> (v x y)

                 (let emission
                   (if (> v 0) (decay-positive x y v display decay color)
                       (< v 0) (decay-negative x y v display decay color)))

                 (comment (assign color (.get-transition display x y))

                          (assign color.red (Math.round (/ color.red *))
                                  color.green (Math.round (/ color.green 4))

                                  color.blue (Math.round (/ color.blue 4))
                                  color.alpha (Math.round (/ color.alpha 4)))

                          (.set display x y color))

                 emission))))

(export Pheremones)

;; Pheremons is a weight matrix.
;; Every value in it is a floating point number from 0 to 1.
;; The values of this matrix influence the decisions of the ants.
;; Pheremons decay by a fixed amount every tick of the simulation unless
;; an ant has recently traversed that location.
;; The result of this is that long paths do not live as long,
;; so the ants will tend towards the shortest path.



(import ( create extend mixin) "./util")
(import (State-space) "./state-space")
(import (euclidian-distance) "./math")
(import (Layer) "./layer")
(import (hexToComplimentary) "./complimentry")

;;(import (each-weight) "./ant")

(let colors [])

(fn decay-positive (x y v display decay color)

    "brings a positive weight closer to zero, "

    (let pixel (.get display x y))


    (blend pixel color v)


    (display.set x y pixel)

    (- v  decay ))

(def combine (old addi ) (Math.round (Math.abs (/ old addi))))

(def blend (color pixel v)

  (let b (combine pixel.red color.red))
  (let r (combine pixel.blue color.blue))
  (let g (combine pixel.green color.green))

  (let a (Math.round (Math.abs (+ pixel.alpha v))))
  (assign pixel.red r pixel.blue b pixel.green g pixel.alpha))

(fn decay-negative (x y v display decay color)

    "brings a positive weight closer to zero, "


    (let pixel  (hexToComplimentary (.get display x y)))
    (blend  pixel color v)


    (display.set x y pixel)
    (+ v  decay ))

(generic each-weight (fn) (weights pos f (size 3) (rad (Math.floor (/ size 2))))

         "apply a function to every element in a kernel of the weight matrix.
Values are not changed unless done so explicitly by the function as a side effect."

         (.each-in-sub weights.state

                       (- pos.x rad)
                       (- pos.y rad)

                       size size (=> (v i j x y ) (f v i j (+ x i) (+ y j)))))

(type Pheremones

      (init ( rate decay color display weights))
      (gmth emit  (pos weights rate (r 5 ))

            (area weights w pos r

                      (when (< w 1)

                        (let new-weight (+ w (/ rate (+ 1 (Math.pow (euclidian-distance x y pos.x pos.y) 2)))))

                        (weights.set x y new-weight))))

      (gmth update (weights display decay color)
            (print "arguments to pheremons update" arguments)

            (weights.transit

             (=> (v x y)
                 (let emission
                   (if (> v 0) (decay-positive x y v display decay color)
                       (< v 0) (decay-negative x y v display decay color)))

                 (assign color (.get-transition display x y))

                 (assign color.red (/ color.red 4)
                         color.green (/ color.green 4)

                         color.blue (/ color.blue 4)) emission))))

(export Pheremones)

(include "./macros/defs")


(include "./macros/js/index")

(import-namespace defs)
(import-namespace js)
(include "./deps")
(macro click (query ...body)
       `(pipe ($ @query)
              (.click (lambda (e)
                        (print "clicked" @query)
                        ...@body))))

(const (literal create extend mixin) (require "./util"))
(const (literal Matrix) (require "./matrix"))

(const $ (require "jquery/dist/jquery.min.js"))
(generic random-bit (def) ( ) (Math.round (Math.random)))

(let canvas (document.get-element-by-id "game"))
(let ctx (.get-context canvas "2d"))

(generic draw-dead (def) (size x y ctx)
         (ctx.stroke-rect (* size x) (* size y) size size))

(generic draw-live (def) (size x y ctx)
         (ctx.fill-rect (* size x) (* y size) size size))
(let min (parse-int (.val ($ "#r-min")) 10))
(let max (parse-int (.val ($ "#r-max")) 10))
(let kernel ((create Matrix)
             [
             1 1 1
             1 0 1
             1 1 1
             ] 3 3))
(def all-zero (w h)
  (let r ((create Matrix) [] w h))
  (.dmap  r (lambda () 0) ))

(def all-ones (w h)
  (let r ((create Matrix) [] w h))
  (.dmap  r (lambda () 1) ))
(def allns (w h n)
  (let r ((create Matrix) [] w h))
  (.dmap  r (lambda () n) ))

;; matrix must have odd height and width to have a single center cell
(def matrix-center (width height )
  (Math.round (/ (- (* width height) 1) 2)))

(generic moore-neighborhood (def) (w h (weight 1) (c 0))
         (let m (allns w h weight))
         (set m.array (matrix-center w h) c) m)

;; Commit this, don't change it.
;; Conways game of life is done, and done.
;; You have a portfolio piece.
(let live 1)
(let dead 0)

(def between (a b)
  (lambda (n) (and  (>= n a) (<= n b))))



(def rules (v x y m)
  (let neighbors (.count game.neighborhood x y m))

  ;; This is a threshold function.
  ;; I could instead use a sigmoid, or other non linearity
  ;; then the cells would need to be non binary grayscale
  (if (= v live)

      (if ((between min max) neighbors) live dead)

      (= neighbors max) live))

(def sigmoid (t) (/ 1 (+ 1 (Math.pow Math.E -t))))


(type Neighborhood
      (init (width height weight (kernel (moore-neighborhood width height weight))))

      (gmth resize (w h weight)
            (assign this.kernel (moore-neighborhood w h weight)
                    this.width w
                    this.height h
                    this.weight weight))

      (gmth sample (m x y kernel)

            (var wr (/ (- kernel.width 1) 2)
                 hr (/ (- kernel.height 1) 2)
                 w kernel.width
                 h kernel.height)

            (.submatrix m (- x wr) (- y hr) w h))

      (gmth count (x y state kernel)
            (var wr (/ (- kernel.width 1) 2)
                 hr (/ (- kernel.height 1) 2)
                 w kernel.width
                 h kernel.height)
            (.convolve-sub state kernel (- x wr) (- y hr))))

(type Game

      (init ((width (.val ($ "#width")))
             (height (.val ($ "#height")))

             (cell-size (.val ($ "#cell-size")))

             (state (.randomize this ))
             (transition (all-zero height width))

             (running false)

             (neighborhood ((create Neighborhood)
                            (.val ($ "#n-width"))
                            (.val ($ "#n-height"))
                            (.val ($ "#n-weight"))))

             (living 0) (generation 0))
            )

      (generic randomize (mth) (width height )
               "create a random board configuration, stops the simulation if its running."

               (print "neighborhood" this.neighborhood)
               (this.stop)

               (var r ((create Matrix) [] width height)
                    set-random-state

                    (-> (let value (random-bit))
                        (if (= value live)
                            (++ this.living)) value))

               (assign this.living 0 this.generation 0
                       this.state (.dmap  r set-random-state)))

      (generic transform (mth) (rules state transition )
               (++ this.generation)
               (assign this.living 0)
               (assign this.state (.transit state transition
                                            (=> (v x y m)
                                                (let r (rules v x y m))
                                                (if (= r live)
                                                    (++ this.living)) r))
                       this.transition state))

      (generic start (mth) ()
               (assign this.running true)
               (.html ($ "#toggle") "stop"))

      (generic stop (mth) ()
               (assign this.running false)
               (.html ($ "#toggle") "start"))

      (generic toggle (mth) (running )
               (assign this.running (not running))
               (.html ($ "#toggle") (ternary this.running "stop" "start")))

      (generic resize (mth) (w h  c)

               (this.stop)
               (Game.init.call this w h c)
               )

      (generic toggle-cell (mth) (x y state)

               (this.stop)
               (let cell (.get-cell state x y)) (if (= cell live)
                   (.set-cell state x y dead)
                   (.set-cell state x y live)))

      (generic draw (mth) (state cell-size )

               (state.each (=> (v x y m)
                               (if (= v 1)
                                   (draw-live cell-size x y ctx)
                                   (draw-dead cell-size x y ctx))))))

(let game ((create Game) ))

(def draw ()
  (ctx.clear-rect 0 0 canvas.height canvas.width)
  (if game.running (game.transform rules))
  (game.draw)
  (.text ($ "#live-cells") game.living)
  (.text ($ "#generations") game.generation)
  (window.request-animation-frame draw)
  )

(click canvas
       (.toggle-cell game
                     (Math.floor (/ (- e.page-x canvas.offset-left) game.cell-size))
                     (Math.floor (/ (- e.page-y canvas.offset-top) game.cell-size))))
(click "#toggle"
       (.toggle game))
(click "#randomize" (game.randomize))
(click "#resize"
        (.resize game
                 (.val ($ "#width"))
                 (.val ($ "#height"))
                 (.val ($ "#cell-size")))
        (.randomize game ))

(click "#n-resize"

       (.resize game.neighborhood

                (parse-int (.val ($ "#n-width")) 10)
                (parse-int (.val ($ "#n-height")) 10)
                (parse-float (.val ($ "#n-weight")) 10))

       (.randomize game ))

(click "#change-rules"

       (assign min (parse-float (.val ($ "#r-min")) 10)
               max (parse-float (.val ($ "#r-max")) 10))

       (.randomize game ))

(window.request-animation-frame draw)
(game.randomize)

(game.start)


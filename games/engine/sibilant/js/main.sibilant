(namespace engine-tests)
(include "kit/header" )
(import-namespace kit)
(include "kit-interface/header" )

(var socket (io "/engine"))
(on socket "change" () (print "change ") (.reload location))

(set global
     'mixin mixin
     'create create
     )
(import-namespace interface)
(def-lit-macro define (name parent ...body)
               `(property @name
                          (.define @parent (quote @name)
                                   (lit ...@body))))
(include "kit-html/src/dom")

(def-lit-macro def-curried (name args ...body) `(property @name (R.curry (lambda @args ...@body))))


(require! (lit Tree-map) "tree-kit")
(import-namespace dom)

(macro random-sign  ( ) `(if (< (Math.random) 0.5) -1 1))

(macro random-signed (max)
       `(scoped
         (var rand (random-float 0 @max))
         (- @max (* rand 2))))

(macro random-float ( min max) `(+ (* (Math.random) (- @max @min)) @min))



(require! (lit Game) "sibilant-game-engine/client/game"
          (lit Rendering) "sibilant-game-engine/client/systems/rendering/rendering"
          (lit Dot) "sibilant-game-engine/client/systems/rendering/dot"
          (lit Position) "sibilant-game-engine/client/systems/position"
          (lit Velocity) "sibilant-game-engine/client/systems/velocity"
          (lit Physics) "sibilant-game-engine/client/systems/physics"
          (lit Scalar) "sibilant-game-engine/client/math/scalar"
          (lit Component System) "sibilant-game-engine/client/ecs/component"
          noise "./noise"
          Vector "./vector"
          (lit create-vector-field update-particle) "./field"
          ;; (lit Matrix-map) "sibilant-game-engine/client/data-structures/"

          (lit Collision) "sibilant-game-engine/client/systems/collision"
          (lit Tree-map) "tree-kit")

(define Friction Physics.Force
        (def apply (c)
             (var v c.velocity)
             (var collision (.get c.system.process.systems Collision c.entity))
             (if (or (< 100 v.xd)
                     (< 100 v.yd)
                     (> -100 v.xd)
                     (> -100 v.yd))
                 (set v
                      'xd (/ v.xd config.friction)
                      'yd (/ v.yd config.friction)))
             (unless collision.colliding
                     (incr-by v.xd (* -0.3 (+ 3 (/ v.xd config.friction))))
                     (incr-by v.yd (* -0.3 (+ 3 (/ v.yd config.friction)))))))
(assign global.size window.size)
(print window.size)
(require! config "./config")
(print (window.size))

(print config)

(const rendering (.load Rendering
                        (lit (size config.dimensions)
                             (limit 100)
                             (blend true))))


(var stage (dom (.div .id 'stage )))


(var container (dom (.div .id "container" rendering.context.canvas)))
(with-dom Document-root (.div .id 'frame container))

(var active-game-systems [Dot Position Physics Velocity Collision])
(var game ((create Game) rendering active-game-systems))


(def entity (aspects ) (.spawn game.ent aspects ))
(def vector2d (x y) [x y])

(def Tree-map.get ((dots args))
     (get (.find this (dots args)) 'value))
(def memoize (f)
     (var cache ((create Tree-map)))
     (=> ((dots args))
         (remember cache args
                   (f (dots args)))))

(var rgba (memoize (=> (r g b a) (lit r g b a))))


(on game.events 'collision ([c c* d])
    (var cv (.get game.systems Velocity c.entity))
    (var c*v (.get game.systems Velocity c*.entity))

    (var cp (.get game.systems Physics c.entity))
    (var c*p (.get game.systems Physics c*.entity))

    (if
     (or (and (= c.entity home)
              (= c*.entity target))

         (and (= c*.entity home)
              (= c.entity target)))
     (do (print "target colliding with spawn"))
     (= c.entity target)
        (do

         (.accelerate cv [(random-signed (or (* (+ 1 c*v.xd) config.collision-static)
                                             config.collision-static)),
                           (random-signed (or (* (+ 1 c*v.yd) config.collision-static)
                                              config.collision-static))])
         (assign c.colliding false)
         (assign c*.colliding false)
         (var hpos (.get game.systems Position home))

         (set c*v.pos
              'x  hpos.x
              'y hpos.y)


         (update-particle c*v c*v.pos, Signal-field.field,
                          Signal-field.layer
                          game.ticker.ticks
                          false
                          true
                          home-pos
                          )
         (.accelerate c*v [(random-signed config.collision-static),(random-signed config.collision-static)])
         )
        (= c*.entity target)
        (do

         (.accelerate c*v [(random-signed (or (* (+ 1 cv.xd) config.collision-static)
                                             config.collision-static)),
                           (random-signed (or (* (+ 1 cv.yd) config.collision-static)
                                              config.collision-static))])


         (assign c.colliding false)
         (assign c*.colliding false)

         (var hpos (.get game.systems Position home))

         (set cv.pos
              'x  hpos.x
              'y hpos.y)

         (update-particle cv cv.pos, Signal-field.field,
                          Signal-field.layer
                          game.ticker.ticks
                          true
                          true
                          home-pos)
         (.accelerate cv [(random-signed config.collision-static),(random-signed config.collision-static)]))

        (not (or (= c.entity home) (= c*.entity home)
                 (= c.entity target) (= c*.entity target)))
        (do

         (assign c.colliding false)
         (assign c*.colliding false)

         ;; (.accelerate cv [(random-signed 1),(random-signed 1)])
         ;; (.accelerate c*v [(random-signed 1),(random-signed 1)])

         (update-particle c*v c*v.pos, Signal-field.field,
                          Signal-field.layer
                          game.ticker.ticks
                          config.decay-on-collision
                          false
                          home-pos

                          )
         
         (update-particle cv cv.pos, Signal-field.field,
                          Signal-field.layer
                          game.ticker.ticks
                          config.decay-on-collision
                          false
                          home-pos
                          )

         )))

(define SignalField Physics.Force

        (field (create-vector-field config.columns
                                    config.rows))

        (layer (create-vector-field config.columns
                                    config.rows))

        (def-generic apply (c, field, layer)
                     (var v c.velocity)
                     (var collision (.get c.system.process.systems Collision c.entity))
                     (unless collision.colliding
                             ;; (print "woosh", v, field, layer)
                             (update-particle v v.pos, field, layer game.ticker.ticks
                                              false
                                              false
                                              home-pos)
                             (var win-rate (/ v.win-count (+ 1 v.loose-count)))
                             (assign c.scale (if (> win-rate 1)
                                                 win-rate
                                                 1)))))

(var home (entity [Dot Position Physics Collision]))
(var home-pos (.get game.systems Position home))

(set (.get game.systems Dot home)
     'color (rgba 0 255 0 255))

(set (.get game.systems Position home )
     'x (random-int 1 (first config.dimensions))
     'y (random-int 1 (second config.dimensions))
     'z 1)

(set (.get game.systems Physics home)
     'scale 30
     'mass 1
     'forces [])


(var target (entity [Dot Position Physics Collision Velocity]))

(set (.get game.systems Dot target)
     'color (rgba 0 0 255 255))

(set (.get game.systems Position target )
     'x (random-int 1 (first config.dimensions))
     'y (random-int 1 (second config.dimensions))
     'z 1)

(set (.get game.systems Physics target)
     'scale 40
     'mass 10000
     'forces [Friction])

;; (set (.get game.systems Velocity target)
;;      ;; 'xd (random-signed 10)
;;      ;; 'yd (random-signed 10)
;;      )

;; (set (.get game.systems Collision target)
;;      'type 'static)

(const ants [])
(def spawn-ant ([x, y], home, starting-life)
     (var ant (entity active-game-systems))
     (.push ants ant)

     (set (.get game.systems Dot ant)
          'color (rgba 255 0 0 255))


     (set (.get game.systems Position ant )
          'x x
          'y y
          'z 1)


     (set (.get game.systems Physics ant)
          'scale 10
          'mass 1
          'forces [SignalField, Friction])
     (var v (.get game.systems Velocity ant))

     (.accelerate v [(random-signed config.spawn-static),(random-signed config.spawn-static)])
     ant)

(var home-pos (.get game.systems Position home))
(var number 1)
(set-interval (-> (unless (>= ants.length config.ant-limit) (spawn-ant [home-pos.x home-pos.y] home))), config.spawn-rate)







(.start game)
